안녕하세요, 소프트웨어공학 01분반 소프트웨어학부 18학번 주영석입니다.

이번 학기 텀 프로젝트 발표를 시작하겠습니다.

발표는 프로젝트 문서의 요구 분석 산출물과 설계 산출물을 간략히 설명 한 뒤, 소스 코드를 보며 설계 및 구현에 대해 설명하고, 마지막으로 간단한 시연을 하겠습니다.

우선 Use case diagram부터 설명하겠습니다. 

요구 문서의 Bridge Game이 플레이어와 상호작용 하는 경우를 다음과 같이 분석했습니다.

플레이어 이외의 다른 에이전트는 존재하지 않고, 플레이어가 지도 로드, 게임 시작부터 주사위 굴리기, 이동하기, 한 턴 쉬기의 Use Case를 통해 Bridge Game 시스템과 상호작용합니다.

다음으로 Use Case 명세입니다. 

Use Case diagram의 각 Use Case에 대해 설명이 되어있습니다.

지도 파일을 로드하는 것 부터 주사위 굴리기, 이동하기, 한 턴 쉬기의 Use Case에 대해 분석했으며, 각각의 Alternative Flow도 설명이 되어있습니다.

다음은 System Sequence Diagram입니다.

각 Use Case Description에서 플레이어가 게임 시스템과 상호작용 하는 것을 Sequence diagram으로 나타내었습니다.

여기서 설명된 시스템 기능에 대해 Operation Contract가 작성되어있으며, 각각의 Precondition과 Postcondition을 분석했습니다.

여기까지 분석한 내용을 바탕으로 매우 기초적인 Domain Model을 작성했습니다.

카드, Direction과 같은 것이 존재하며, 카드와 셀을 가지는 셀, 그리고 셀을 가지는 맵과 플레이어를 만들고, 전체 브릿지 게임 시스템을 구상했습니다.

다음으로 설계 산출물입니다.

MVC 패턴에 맞추어 설계를 하였으며, 각각의 Design Class Diagram을 작성한 뒤, 모든 부분을 합쳐 전체 Class Diagram을 다음과 같이 설계했습니다.

우선 모델 부분입니다. 

가장 먼저 카드, 방향과 같은 클래스를 Enum 클래스로 지정해주었습니다. 

다음으로 플레이어와 셀 클래스를 만들고, 플레이어는 카드 여러장을 가질 수 있고, 셀은 카드 한장과 플레이어 여러 명을 가질 수 있도록 설계했습니다.

여기서 만든 셀을 바탕으로 다양한 셀을 생성했습니다. 이들 모드 셀을 상속받아 셀의 기능을 할 수 있도록 구현했습니다.

또한 지도 정보로서 여러 셀을 어레이로 가지는 게임 맵이라는 클래스를 설계했습니다.

여기서 도메인 모델에서는 생각하지 못한, 다리에 관한 정보를 저장하기 위해 브릿지 스타트 셀, 브릿지 엔드 셀을 가지는 브릿지 인포라는 추가적인 클래스를 생성했고, 
이 또한 게임 맵 클래스에서 어레이로 지니도록 했습니다.

마지막으로 게임의 모든 로직을 담당하는 게임 모델이라는 클래스를 만들었습니다. 해당 클래스는 MVC 패턴에서 모델을 대표하는 클래스입니다.

다음은 뷰입니다. MVC 패턴에서 뷰를 대표하는 게임뷰라는 클래스가 존재하고, 이 클래스에서 gui를 띄우는 게임 프레임이라는 클래스를 생성하도록 설계했습니다.

아직 gui 버전밖에 구현이 되어있지 않지만, 추후 cui 버전을 추가할 때 게임 뷰 클래스에 cui를 만드는 기능을 추가하기 쉽도록 설계했습니다.

게임 프레임에서는 지도를 띄우는 맵 패널, 게임 상태를 띄우는 게임 패널, 유저가 직접 조작할 수 있는 버튼을 띄우는 컨트롤 패널로 구성했습니다.

마지막으로 MVC에서 컨트롤러를 담당하는 게임 컨트롤러 클래스입니다.

하나의 클래스만 존재하며, 생성자에서 뷰 객체를 생성합니다.

뷰에서 상호작용할 수 있는 메서드가 존재하며, 간단한 로직 판별과 모델의 메서드를 호출하는 부분으로 구성되어 있습니다.

다만 컨트롤러가 모델의 메서드를 호출 한 뒤 뷰를 직접 업데이트 하지 않는, 옵저버 패턴으로 게임 전체를 설계했습니다.

모델과 뷰에 각각 옵저버블, 옵저버 인터페이스를 만든 뒤, 각각이 이 인터페이스를 implement 하도록 설계했습니다.

더 자세히는, 뷰에서 지도를 표시하는 부분과 플레이어 및 게임의 상태를 표시하는 부분이 나뉘어 있기 때문에, 맵 옵저버와 게임 옵저버 두가지를 따로 구현했습니다.

게임 모델 클래스는 이 두가지의 옵저버블 모두를 구현하여 각각 상황에 맞는 로직에서 구독자를 업데이트 하는 기능을 만들었습니다.

사용자가 한 턴 쉬기를 한 경우, 맵의 업데이트는 없고 게임의 상태만 업데이트 되므로 해당 로직에서는 게임 옵저버만 업데이트 하도록 설계한것이 그 예입니다.

이러한 설계를 바탕으로 나타낸 시퀀스 다이어그램입니다.

플레이어 액터가 게임의 진입점인 브릿지 게임 클래스의 메인 함수를 실행하면 해당 클래스는 게임 모델을 생성하고, 컨트롤러를 생성합니다.

컨트롤러는 뷰를 생성하도록 설계했습니다.

자세한 다이어그램은 프로젝트 폴더의 uml 디렉터리에 모든 uml 파일과 사진 파일이 존재하므로 참고 바랍니다.

다음으로 간단히 소스코드를 살펴보겠습니다. 

src 폴더 내에 브릿지 게임이라는 진입 클래스가 있습니다.

이 함수에서 다음과 같이 모델을 생성하고 컨트롤러를 생성하며 모델을 전달해줍니다.

모델의 구조는 다음과 같습니다.

다음으로 컨트롤러에서 뷰를 생성하는데, 모델과 컨트롤러 자신을 뷰에게 전달합니다.

게임뷰 클래스는 다음과 같습니다. 이 부분에서 사용자가 디스플레이 모드를 선택하도록 구현했으며, 현재 gui밖에 없지만 추후 추가하기 쉽도록 설계했습니다.

다음으로 간단한 시연을 하겠습니다.